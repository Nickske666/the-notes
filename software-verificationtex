\documentclass[oneside,a4paper]{book}\usepackage{fancyhdr}\pagestyle{fancy}\lhead{}\chead{{\large{}\textsc{the notes}}}\rhead{}\lfoot{Tom Sydney Kerckhove}\cfoot{}\rfoot{\thepage{}}\renewcommand{\headrulewidth}{0.40000pt}\renewcommand{\footrulewidth}{0.40000pt}\makeindex\theoremstyle{definition}\newtheorem{thm}{Theorem}[chapter]\newtheorem{prop}[thm]{Property}\newtheorem{pro}[thm]{Proposition}\newtheorem{nte}[thm]{Note}\newtheorem{ex}[thm]{Example}\newtheorem{cex}[thm]{Counterexample}\newtheorem{con}[thm]{Concequence}\newtheorem{lem}[thm]{Lemma}\newmdtheoremenv{de}[thm]{Definition}\newmdtheoremenv{alg}[thm]{Algorithm}\renewcommand{\arraystretch}{1.25000}\renewcommand{\qedsymbol}{$\square$}\renewcommand{\leq}{\leqslant{}}\renewcommand{\geq}{\geqslant{}}\setlength\parindent{0pt}\begin{document}\begin{titlepage}
\thispagestyle{empty}\hbox{
\rule{1.0pt}{\textheight}\hspace{1.00000pt}
\rule{2.0pt}{\textheight}\hspace{2.00000pt}
\rule{3.0pt}{\textheight}\hspace{3.00000pt}
\rule{4.0pt}{\textheight}\hspace{4.00000pt}
\rule{5.0pt}{\textheight}\hspace{5.00000pt}
\rule{6.0pt}{\textheight}\hspace{6.00000pt}
\rule{7.0pt}{\textheight}\hspace{7.00000pt}
\hspace*{0.05\textwidth}\parbox[b]{0.75\textwidth}{
\noindent{}{\fontsize{80}{90}\selectfont{}\textbf{The Notes}}\\
[1.0\baselineskip]{\Huge{}\textbf{Software Verification}}\\
[2.5\baselineskip]
{\huge{}\textsc{Tom Sydney Kerckhove}}\\
[4.0\baselineskip]{\large{}\begin{tabular}{ll}Started&September 28, 2015\\Compiled&\today\\Commit&\input{commit.tex}\\\end{tabular}}\vspace{0.5\textheight}}}\end{titlepage}\tableofcontents{}\newpage{}\vspace{1.00000cm}The code for this pdf was generated by running the `the notes' generator with the following configuration.\begin{verbatim}Config {conf_selection = [Match ["logic"],Match ["computability"]], conf_visualD
ebug = True, conf_verbose = False, conf_ignoreReferenceErrors = True, conf_omitT
odos = False, conf_subtitle = Just "Software Verification", conf_texFileName = "
software-verification", conf_bibFileName = "software-verification", conf_pdfFile
Name = "software-verification"}\end{verbatim}
\newpage{}\chapter{Logic}\section{Abstract Logic}It is hard to speak about logic in a pure mathematical fashion as it originated, and still borders on, philosophy. \begin{de}A \index{formula}\textbf{formula} is a string of characters. \end{de}\begin{nte}In fact a formula can be equivalently be defined in other ways but this definition suffices. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:theory}}\\\label{definition:theory}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:logic}}\\\label{definition:logic}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:axiom}}\\\label{definition:axiom}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:grammar}}\\\label{definition:grammar}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:semantics}}\\\label{definition:semantics}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:sentence}}\\\label{definition:sentence}A \index{theory}\textbf{theory} or \index{logic}\textbf{logic} is a mathematical framework for proving properties about a certain object domain. Those properties are called \index{theorem}theorems. A \index{theory}theory consists of a \index{grammar}\textbf{grammar}, a set of \index{axiom}\textbf{axiom}s and \index{semantics}\textbf{semantics} for formulae. \begin{enumerate}\item{}A \index{grammar}\textbf{grammar} defines well-formed formulae. A well-formed \index{formula}formula is also called a \index{sentence}\textbf{sentence}. A \index{formula}\textbf{formula} represents an expression if it adheres to the \index{grammar}grammar. \item{}An \index{axiom}\textbf{axiom} is a \index{theorem}theorem that can be asserted without \index{inference}inference. \item{}Semantics dictate the \emph{meaning} of formulae in the \index{logic}logic. \end{enumerate}\end{de}\begin{nte}Theorems are obtained from the axioms by a finite amount of applications of the inference rules. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:world}}\\\label{definition:world}A logical \index{world}\textbf{world} is a set of boolean expressions that are true within the framework of certain theory. \todo[color=red,inline,size=\small]{There is a reference to ``boolean expression'' missing here. }\end{de}\begin{de}An axiom schema defines multiple (possibly even infinitely many) axioms via the use of a variable. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:knowledge-base}}\\\label{definition:knowledge-base}A \index{knowledge base}\textbf{knowledge base} is a set of boolean expressions in the context of a certain logical world. In a given world, a valid \index{knowledge base}knowledge base is a subset of that world. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:theorem}}\\\label{definition:theorem}A \index{theorem}\textbf{theorem} $f$ is a well-formed formula that is provable in a theory $\mathbb{T}$. This is de:: Noted as $\vdash{}f$. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:entails}}\\\label{definition:entails}Let $\mathbb{T}$ be a \index{theory}theory and $KB$ a \index{knowledge base}knowledge base. We say that a \index{knowledge base}knowledge base $KB$ \index{entails}\textbf{entails} a boolean expression $\alpha{}$ if $\alpha{}$ is true in all worlds where $KB$ is a valid \index{knowledge base}knowledge base. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:model}}\\\label{definition:model}We say a world $m$ is a \index{model}\textbf{model} of an expression $\alpha{}$ if $\alpha{}$ is true in $m$. \end{de}\begin{de}The set of all models of an expression $\alpha{}$ is de:: Noted as $M\kern-2pt\left(\alpha{}\right)$.. \end{de}\begin{nte}With a little notation overloading we also de:: Note ``The intersection of the set of all models of the expressions in a set $S$. '' as $M\kern-2pt\left(S\right)$. \[M\kern-2pt\left(S\right)={\bigcap_{{s\in{}S}}}{M\kern-2pt\left(s\right)}\]\end{nte}\begin{de}Another way of expressing the fact that an expression $\alpha{}$ is entailed by a \index{knowledge base}knowledge base $KB$: $KB\vDash{}\alpha{}$ is using models. \[M\kern-2pt\left(KB\right)\subseteq{}M\kern-2pt\left(\alpha{}\right)\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:inference}}\\\label{definition:inference}An \index{inference}\textbf{inference} $i$ in a theory $\mathbb{T}$ is a procedure for proving sentences from a \index{knowledge base}knowledge base. If a theorem $\mathbb{T}$ can be proven using $i$ we de:: Note this as ${\vdash}_{i}f$. \end{de}\begin{de}An inference rule is written as follows. It means that if theorems ${f}_{1}, {f}_{2}, \dotsc{}, {f}_{n}$ can be asserted, we may assert ${f}_{0}$ as a theorem. \[\infer{{f}_{0}}{{f}_{1},\,{f}_{2},\,\dotsc{},\,{f}_{n}}\]The sentences above the line are called the \index{hypotheses}\textbf{hypotheses} or antecedents and the sentence below the line is called the \index{conclusion}\textbf{conclusion}. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:sound}}\\\label{definition:sound}An \index{inference}inference $i$ is called \index{sound}\textbf{sound} if every \index{theorem}theorem produced by $i$ is a true \index{formula}formula. \[\forall{}\alpha{}, KB:\ KB{\vdash}_{i}\alpha{}\Rightarrow{}KB\vDash{}\alpha{}\]\end{de}\begin{de}An \index{inference}inference $i$ is called \index{complete}\textbf{complete} if every true \index{formula}formula can be established as a theorem by $i$. \[\forall{}\alpha{}, KB:\ KB\vDash{}\alpha{}\Rightarrow{}KB{\vdash}_{i}\alpha{}\]\end{de}\begin{ex}Let $\mathbb{I}$ be a theory with a \index{grammar}grammar ${G}_{\mathbb{I}}$ a set ${I}_{\mathbb{I}}$ of inference rules and a set ${A}_{\mathbb{I}}$ of axioms. \begin{enumerate}\item{}${G}_{\mathbb{I}}$ defines a formula to be well-formed if it is of the following form: \begin{itemize}\item{}`${i}_{1}={i}_{2}$' where ${i}_{1}$ and ${i}_{2}$ are integer expressions. \item{}`${i}_{1}<{i}_{2}$' where ${i}_{1}$ and ${i}_{2}$ are integer expressions. \item{}`$\neg{}b$' where $b$ is a boolean expression. \item{}`${b}_{1}\Rightarrow{}{b}_{2}$' where ${b}_{1}$ and ${b}_{2}$ are boolean expressions. \end{itemize}An `integer expression' is an expression of one the following forms. \begin{itemize}\item{}$0$\item{}A variable $n$\item{}$S\kern-2pt\left(n\right)$ Where $n$ is an integer expression. \end{itemize}\item{}The axioms are $\vdash{}0<S\kern-2pt\left(0\right)$ and the axioms defined by the following axiom schema:\[\vdash{}f<g\Rightarrow{}S\kern-2pt\left(f\right)<S\kern-2pt\left(g\right)\]\end{enumerate}In this example theory, the following could be a sound, but not complete, inference rule:\[\infer{\forall{}f:\ P\kern-2pt\left(f\right)}{S\kern-2pt\left(0\right),\,\forall{}f:\ P\kern-2pt\left(f\right)\Rightarrow{}P\kern-2pt\left(S\kern-2pt\left(f\right)\right)}\]This rule is called \index{induction}\textbf{induction}.\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:modus-ponens}}\\\label{definition:modus-ponens}The \index{modus ponens}\textbf{modus ponens} \index{inference}inference rule is common to many theories. \[\infer{q}{p,\,p\Rightarrow{}q}\]\end{de}\section{Propositional Logic}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:propositional-logic}}\\\label{definition:propositional-logic}The \index{Propositional logic}\textbf{Propositional logic} has a \index{grammar}grammar ${G}_{\mathbb{I}}$ and only two axioms. \begin{enumerate}\item{}${G}_{\mathbb{I}}$ defines well formed formulas recursively with the following cases. \begin{itemize}\item{}``true'' and ``false'' are sentences. \item{}So-called propositional symbols, boolean variables, are sentences. \item{}If $S$ is a sentence, then $\neg{}S$ is a sentence and it is true only if $S$ is not. \item{}If ${S}_{1}$ and ${S}_{2}$ are sentences, then ${S}_{1}\vee{}{S}_{2}$ is a sentence and it is true only if one of ${S}_{1}$ and ${S}_{2}$ are true. \item{}If ${S}_{1}$ and ${S}_{2}$ are sentences, then ${S}_{1}\wedge{}{S}_{2}$ is a sentence and it is true only if both ${S}_{1}$ and ${S}_{2}$ are true. \end{itemize}\item{}The sentences ``true'' and ``false'' are respesctively asserted to be true and false. \end{enumerate}In propositional logic, a world defines a truth value to every propositional symbol. \end{de}\begin{nte}There are some very common notational shorthands in propositional logic.\begin{itemize}\item{}``${S}_{1}\Rightarrow{}{S}_{2}$'' for ``$\neg{}{S}_{1}\vee{}{S}_{2}$''. \item{}``${S}_{1}\Leftrightarrow{}{S}_{2}$'' for ``$\left({S}_{1}\Rightarrow{}{S}_{2}\right)\wedge{}\left({S}_{2}\Rightarrow{}{S}_{1}\right)$''. \end{itemize}\end{nte}\begin{nte}Truth tables are a very common and naive way of reasoning about sentences propositional logic. The validity of a proposition is checked by enumerating the truth table for the sentence and checking whether all the values in the column for the sentence are true. \begin{figure}[H]\centering{}$\begin{array}[c]{|c|c|}\hline A&\neg{}A\\\hline \hline true&false\\\hline false&true\\\hline \end{array}$\end{figure}\begin{figure}[H]\centering{}$\begin{array}[c]{|c|c|c|c|}\hline A&B&A\vee{}B\\\hline \hline false&false&false\\\hline false&true&true\\\hline true&false&true\\\hline true&true&true\\\hline \end{array}$$\quad{}$$\begin{array}[c]{|c|c|c|c|}\hline A&B&A\wedge{}B\\\hline \hline false&false&false\\\hline false&true&false\\\hline true&false&false\\\hline true&true&true\\\hline \end{array}$\end{figure}\begin{figure}[H]\centering{}$\begin{array}[c]{|c|c|c|c|}\hline A&B&A\Rightarrow{}B\\\hline \hline false&false&true\\\hline false&true&true\\\hline true&false&false\\\hline true&true&true\\\hline \end{array}$$\quad{}$$\begin{array}[c]{|c|c|c|c|}\hline A&B&A\Leftrightarrow{}B\\\hline \hline false&false&true\\\hline false&true&false\\\hline true&false&false\\\hline true&true&true\\\hline \end{array}$$\quad{}$$\begin{array}[c]{|c|c|c|c|}\hline A&B&A\oplus{}B\\\hline \hline false&false&false\\\hline false&true&true\\\hline true&false&true\\\hline true&true&false\\\hline \end{array}$\caption{Elementary truth tables}\end{figure}\end{nte}\subsection{Normal forms}\subsubsection{Conjunctive Normal Form}\begin{de}A sentence in propositional logic is said to be in \index{conjunctive normal form}\textbf{conjunctive normal form} or \index{clausal normal form}\textbf{clausal normal form} (\index{CNF}\textbf{CNF}) if it is a conjunction of clauses where a clause is a disjunction of literals. \end{de}\begin{thm}Every sentence propositional logic can be converted into an equivalent formula that is in CNF. \newline{}\textit{no proof}\newline{}There is a famous transformation called the \index{Tseitin transformation}\textbf{Tseitin transformation} that does exactly this. \cite{tseitin68}\end{thm}\subsection{Inference in propositional logic}\begin{de}The \index{inference}inference \index{rule of resolution}\textbf{rule of resolution} is an inference in proposition logic. Let $a$ and $b$ be propositional formulae in CNF.. \[a={a}_{1}\vee{}{a}_{2}\vee{}\dotsc{}\vee{}{a}_{k}\quad{}b={b}_{1}\vee{}{b}_{2}\vee{}\dotsc{}\vee{}{b}_{l}\]Suppose also that, for some $i$ and $j$, ${a}_{i}=\neg{}{b}_{j}$ holds. \[\infer{{a}_{1}\vee{}{a}_{2}\vee{}\dotsc{}\vee{}{a}_{i-1}\vee{}{a}_{i+1}\vee{}\dotsc{}\vee{}{a}_{k}\vee{}{b}_{1}\vee{}{b}_{2}\vee{}\dotsc{}\vee{}{b}_{j-1}\vee{}{b}_{j+1}\vee{}\dotsc{}\vee{}{b}_{k}}{{a}_{1}\vee{}{a}_{2}\vee{}\dotsc{}\vee{}{a}_{k},\,{b}_{1}\vee{}{b}_{2}\vee{}\dotsc{}\vee{}{b}_{l}}\]\end{de}\begin{thm}This \index{inference}inference is \index{sound}sound and \index{complete}complete.. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{nte}Eventhough this \index{inference}inference is \index{sound}sound and \index{complete}complete, finding proofs can be difficult as search spaces become exponentially large. \todo[color=red,inline,size=\small]{Citation needed}\end{nte}\section{First Order Logic}\begin{de}While propositional logic is about simple facts, first order logic is about complex facts involving objects, relations, functions, etc.... \index{first order logic}\textbf{first order logic} is a \index{theory}theory. It is an extension of propositional logic with predicates, functions, variables and their quantifiers. Remember that these symbols are just that, symbols. \end{de}\begin{de}A \index{term}\textbf{term} in first order logic is either a constant symbol, a variable or a $k$-ary function symbol applied to terms. \end{de}\begin{ex}``$1$'', ``$2$'', ``$3$'', ``$x$'', ``$f\kern-2pt\left(x\right)$'' are terms in first order logic. \end{ex}\begin{de}A sentence in first order logic is called \index{atomic}\textbf{atomic} if it is a constant symbol or a function of only constant symbols. \end{de}\begin{ex}``$1$'', ``$Small\kern-2pt\left(1\right)$'', ``$Smaller\kern-2pt\left(1, 2\right)$'' are atomic sentences in first order logic. \end{ex}\begin{de}A sentence in first order logic is called \index{composite}\textbf{composite} if it atomic, contains free variables an quantifiers, or is composed of composite sentences joined by connectives. \end{de}\begin{ex}``$1$'', ``$Greater\kern-2pt\left(2, 1\right)$'', ``$Great\kern-2pt\left(x\right)$'', ``$\forall{}y:\ Great\kern-2pt\left(x\right)\vee{}Greater\kern-2pt\left(x, y\right)$'' are composite sentences in first order logic. \end{ex}\begin{de}A \index{model}model in first order logic consists of instantiations of objects, relations and functions. Any constants not in the model is asserted to be false. \end{de}\subsection{Quantifiers}Quantifiers bind free variables. \begin{de}The \index{existential quantifier}\textbf{existential quantifier} $\exists{}$ . A sentence $\exists{}x:\ P\kern-2pt\left(x\right)$, in the context of a model $m$ is defined to hold true if there exists a $x$ in $m$ such that the predicate $P$ holds for $x$. \end{de}\begin{de}The \index{universal quantifier}\textbf{universal quantifier} $\forall{}$ . A sentence $\forall{}x:\ P\kern-2pt\left(x\right)$, in the context of a model $m$ is defined to hold true if the predicate $P$ holds for every instantiation of $x$ in $m$. \end{de}\begin{thm}The order of multiple contiguous existential quantifiers does not matter. \[\left(\exists{}x:\ \exists{}y:\ P\kern-2pt\left(x, y\right)\right)\Leftrightarrow{}\left(\exists{}y:\ \exists{}x:\ P\kern-2pt\left(x, y\right)\right)\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}The order of multiple contiguous universal quantifiers does not matter. \[\left(\forall{}x:\ \forall{}y:\ P\kern-2pt\left(x, y\right)\right)\Leftrightarrow{}\left(\forall{}y:\ \forall{}x:\ P\kern-2pt\left(x, y\right)\right)\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{cex}The order of different quantifiers \textbf{does} matter. \[\neg{}\left(\left(\exists{}x:\ \forall{}y:\ P\kern-2pt\left(x, y\right)\right)\Leftrightarrow{}\left(\forall{}y:\ \exists{}x:\ P\kern-2pt\left(x, y\right)\right)\right)\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{cex}\begin{thm}Each quantifier can be expressed in terms of the other. \[\left(\forall{}x:\ P\kern-2pt\left(x\right)\right)\Leftrightarrow{}\left(\neg{}\exists{}x:\ \neg{}P\kern-2pt\left(x\right)\right)\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\subsection{Situational Calculus}The use of \index{situational calculus}\textbf{situational calculus} is to model situations. In situational calculus, facts hold at a certain moment and/or in a certain situation. This is modeled by adding a situational argument to every non-eternal predicate. Situational calculus can be used to model change, non-change, actions, perceptions, etc.... \subsubsection{The frame problem}Now that we can model situations using frames, there is a need for so called \index{effect axioms}\textbf{effect axioms} that model changes due to actions. In addition to modeling change, one must also model non-change. The frame problem is that the number of frame axioms can be become large and even infinite. This poses problems in automated inference. To solve the problem, we will use so called \index{successor state axioms}\textbf{successor state axioms} that model how each non-eternal predicate is affected or not affected by actions. These successor state axioms model the fact that a predicate is true if and only if an action made it true or it was already true and no action made it false. \subsubsection{Planning using first order logic}First order logic can be used to plan actions based on a knowledge base of known facts. The idea is to decide what the goal situation is and to model it. Then, automated inference can be used to find out whether the given knowledge base entails the goal situation. \subsection{Inference in first order logic}Inference in first order logic is more complicated than inference in propositional logic. In general, there are two approaches: Propositionalisation and ``lifted'' inference. \begin{de}\index{propositionalisation}\textbf{propositionalisation} is an \index{inference}inference in first order logic. It consists of replacing all quantified variables with so called \index{grounding variables}\textbf{grounding variables} using each possible term. This turns the problem into a propositional logic problem and it can then be solved as discussed before. \end{de}The problem with proportionalisation is that the solver may need to create a lot of unnecessary symbols. Even worse, the amount of created symbols could be infinite. \begin{thm}\index{Herbrand's theorem}\textbf{Herbrand's theorem}. \newline{}If a sentence in entailed by a first order logic knowledge base, then there exists a proof using only a finite subset of the propositionalized knowledge base. \cite{herbrand-theorem}\end{thm}Given this theorem, we can propose a naive algorithm to test whether a given sentence $\alpha{}$ is entailed by a given first order logic knowledge base. The algorithm consists of enumerating all finite subsets of the propositionalised knowledge base $KB\cup{}\neg{}\alpha{}$ and checking whether they are satisfiable one by one using propositional resolution. Note that this algorithm will stop if the given sentence is entailed by the given knowledge base but will never stop otherwise. This is intrinsic to the problem. First order logic is only semi-decidable. \index{lifted inference}\textbf{lifted inference} is a set of \index{inference}inferences in first order logic. It consists of trying to infer sentences \emph{without} instantiating variables at all using propositional inference by lifting its inferences. \begin{de}The \index{generalized modus ponens}\textbf{generalized modus ponens} is an \index{inference}inference in first order logic. Let ${p'}_{1}, \dotsc{}, {p'}_{n}$ and ${p}_{1}, \dotsc{}, {p}_{n}$ be sentences in first order logic. Let $\theta{}$ be a substitution and $Subst\kern-2pt\left(\theta{}, q\right)$ its application to $q$. Suppose $Subst\kern-2pt\left(\theta{}, {p'}_{i}\right)=Subst\kern-2pt\left(\theta{}, {p}_{i}\right)$ holds. \[\infer{Subst\kern-2pt\left(\theta{}, q\right)}{{p'}_{1}, \dotsc{}, {p'}_{n},\,{p}_{1}\wedge{}\dotsb{}\wedge{}{p}_{n}\Rightarrow{}q}\]\end{de}\begin{thm}The generalized modus ponens is not \index{complete}complete. \todo[color=red,inline,size=\small]{There either is a proof missing here or a confirmation that no proof is required at all.}\end{thm}There also exists a lifted variant of resolution. \todo[color=red,inline,size=\small]{Describe this variant}It is sound and refutation-complete. \todo[color=red,inline,size=\small]{define refutation-complete}\section{Hoare Logic}\index{Hoare logic}\textbf{Hoare logic} is used to reason about imperative computer programs in abstract machines that have a \index{state}state. \begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:state}}\\\label{definition:state}A \index{state}\textbf{state} is an assignment of values to abstract symbols. \end{de}\begin{nte}In computers these values are typically finite strings of bits but they can be arbitrary values in theory. In logical reasoning, the values are typically (unbounded) integers. \end{nte}\begin{ex}$a\mapsto{}4, b\mapsto{}3$ could be a \index{state}state. \end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:evaluation}}\\\label{definition:evaluation}The \index{evaluation}\textbf{evaluation} ${\left[|b|\right]}_{S}$ of a symbol $b$ with respect to a program state $S$ is the value of $b$ in $S$. \[{\left[|b|\right]}_{S}=a\Leftrightarrow{}b\mapsto{}a\in{}a\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:instruction}}\\\label{definition:instruction}An \index{instruction}\textbf{instruction} in such an abstract machine is a procedure of modifying that \index{state}state. \end{de}\begin{nte}While we say `modify' it is perfectly valid to model a modification as a reconstruction with different variables. There is no real difference in math, but this difference manifests itself physically in real machines. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:assertion}}\\\label{definition:assertion}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:satisfies}}\\\label{definition:satisfies}An \index{assertion}\textbf{assertion} is a predicate on the set of posssible program states. A program \index{state}state $S$ \index{satisfies}\textbf{satisfies} an \index{assertion}assertion if the \index{assertion}assertion holds for that program state. \todo[color=red,inline,size=\small]{define assertions recursively, see the separation logic part}\end{de}\begin{ex}$x\mapsto{}5, y\mapsto{}10\vDash{}x<y\wedge{}x>0$\end{ex}\begin{ex}$x\mapsto{}25\vDash{}\exists{}y:\ y>x$ holds. Note that the $y$ doesn't have to be the value of a variable. \end{ex}\begin{de}$a:=b$ represents the instruction to assign the value of $b$ to the variable a. \end{de}\begin{ex}If the program state holds $a\mapsto{}3, b\mapsto{}5$ and the instruction $a:=b$ is performed, the state afterwards would be $a\mapsto{}5, b\mapsto{}5$. \end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:hoare-logic}}\\\label{definition:hoare-logic}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:hoare-triple}}\\\label{definition:hoare-triple}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:precondition}}\\\label{definition:precondition}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:postcondition}}\\\label{definition:postcondition}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:partial-correctness}}\\\label{definition:partial-correctness}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:total-correctness}}\\\label{definition:total-correctness}\index{Hoare logic}\textbf{Hoare logic} is a \index{theory}theory. In \index{Hoare logic}Hoare logic, well-formed \index{formula}formulae are \index{Hoare triple}\textbf{Hoare triple}s. \[\left\{P\right\}\,A\,\left\{Q\right\}\]Here, $P$ and $Q$ are assertions and $A$ is a sequence of instructions for an abstract machine. $P$ is called the \index{precondition}\textbf{precondition} and $Q$ is called the \index{postcondition}\textbf{postcondition}. An \index{assertion}\textbf{assertion} is a \index{predicate}predicate on the set of states. A true sencence in \index{Hoare logic}Hoare logic describes the fact that the program $A$ will, started in any machine \index{state}state satisfying $P$ will, if it terminates, yield a \index{state}state satisfying $Q$. This is called \index{partial correctness}\textbf{partial correctness}. If a \index{Hoare triple}Hoare triple is partially correct and $A$ is guaranteed to \emph{terminate} as well, this is called \index{total correctness}\textbf{total correctness}. \end{de}\begin{nte}An employee that needs to implement correct programs for given pre- and postconditions should look for the strongest preconditions and the weakest postconditions. Specifications as such will leave him with the least amount of work to do. The following Hoare specification would give him the best job in the world. \[\left\{false\right\}\,A\,\left\{P\right\}\]Any program $A$ is totally correct with respect to this specification. \newline{}The second best job in the world would be the following specification. \[\left\{\right\}\,A\,\left\{true\right\}\]Any program $A$ is partially with respect to this specification. The only thing the programmer would have to do is to make sure that the program terminates. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:consequence}}\\\label{definition:consequence}The  rule of \index{consequence}consequence is an \index{inference}inference in \index{Hoare logic}Hoare logic. \[\infer{\left\{P'\right\}\,A\,\left\{Q'\right\}}{\left\{P\right\}\,A\,\left\{Q\right\},\,P'\Rightarrow{}P,\,Q\Rightarrow{}Q'}\]A precondition can be replaced with a stronger precondition and a postcondition can be replaced by a weaker postcondition. \end{de}\begin{ex}\[\infer{\left\{x>3\right\}\,y:=x+2\,\left\{y>0\right\}}{\left\{x>1\right\}\,y:=x+2\,\left\{y>2\right\},\,x>3\Rightarrow{}x>1,\,y>0\Rightarrow{}y>2}\]\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:conjunction}}\\\label{definition:conjunction}The  rule of \index{conjunction}\textbf{conjunction} is an \index{inference}inference in \index{Hoare logic}Hoare logic. \[\infer{\left\{P\right\}\,A\,\left\{Q\wedge{}R\right\}}{\left\{P\right\}\,A\,\left\{Q\right\},\,\left\{P\right\}\,A\,\left\{R\right\}}\]\end{de}\begin{ex}\[\infer{\left\{true\right\}\,x:=3\,\left\{x>2\wedge{}x>4\right\}}{\left\{true\right\}\,x:=3\,\left\{x>2\right\},\,\left\{true\right\}\,x:=3\,\left\{x<4\right\}}\]\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:sequential-composition}}\\\label{definition:sequential-composition}The  rule of \index{sequential composition}\textbf{sequential composition} is an \index{inference}inference in \index{Hoare logic}Hoare logic. \[\infer{\left\{P\right\}\,A;\ B\,\left\{R\right\}}{\left\{P\right\}\,A\,\left\{Q\right\},\,\left\{Q\right\}\,B\,\left\{R\right\}}\]Instructions can be sequenced as long as their conditions line up. \end{de}\begin{ex}\[\infer{\left\{x>0\right\}\,x:=x+3;\ x:=x+1\,\left\{x>4\right\}}{\left\{x>0\right\}\,x:=x+3\,\left\{x>3\right\},\,\left\{x>3\right\}\,x:=x+1\,\left\{x>4\right\}}\]\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:skip}}\\\label{definition:skip}The \index{skip}\textbf{skip} \index{Hoare triple}Hoare triple is an \index{axiom schema}axiom schema in \index{Hoare logic}Hoare logic. \[\forall{}P:\ \left\{P\right\}\,\index{skip}skip\,\left\{P\right\}\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:abort}}\\\label{definition:abort}The \index{abort}\textbf{abort} \index{Hoare triple}Hoare triple is an \index{axiom schema}axiom schema in \index{Hoare logic}Hoare logic. \[\forall{}P:\ \left\{false\right\}\,\index{abort}abort\,\left\{P\right\}\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:substitution}}\\\label{definition:substitution}$P\left[e / x\right]$ is the expression obtained from $P$ by \index{substitution}\textbf{substitution} of every occurence of $x$ by $e$. Read it as ``$P$ with $e$ instead of $x$. ''. \end{de}\begin{ex}``$\left(y:=x\right)\left[z / y\right]$'' = ``$z:=x$''\end{ex}\begin{ex}``$\left(y:=x\right)\left[x+1 / x\right]$'' = ``$x:=x+1$''\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:assignment}}\\\label{definition:assignment}The \index{assignment}\textbf{assignment} of variables is an \index{axiom schema}axiom schema in \index{Hoare logic}Hoare logic. \[\forall{}P, e, x:\ \left\{P\left[e / x\right]\right\}\,x:=e\,\left\{P\right\}\]\end{de}\begin{ex}$\left\{y>z-2\right\}\,x:=x+1\,\left\{y>z-2\right\}$\end{ex}\begin{ex}$\left\{2+2=5\right\}\,x:=x+1\,\left\{2+2=5\right\}$\end{ex}\begin{ex}$\left\{y>0\right\}\,x:=y\,\left\{x>0\right\}$\end{ex}\begin{ex}$\left\{x+1>0\right\}\,x:=x+1\,\left\{x>0\right\}$Make sure to read this twice. Notice that it is not at all useful in this context. \end{ex}\begin{ex}The \index{assignment}assignment \index{axiom schema}axiom schema can \textbf{not} be used to prove following \index{Hoare triple}Hoare triple. \[\left\{x>0\right\}\,x:=x+1\,\left\{x>1\right\}\]\todo[color=red,inline,size=\small]{Why? More of an explanation is missing here.}\end{ex}\begin{nte}There are limits to the assignment axiom schema. It is assumed that the assigned expression is side-effect-free. This always holds in mathematics, but infrequently in real machines. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:forward-assignment}}\\\label{definition:forward-assignment}There is also a `forward version' of the assignment axiom. \[\left\{P\right\}\,x:=e\,\left\{\exists{}{x}^{old}:\ \left(P\left[{x}^{old} / x\right]\right)\wedge{}\left(x=e\left[{x}^{old} / x\right]\right)\right\}\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:free-variable}}\\\label{definition:free-variable}A variable $x$ is said to be a \index{free variable}\textbf{free variable} in an expression $P$ if $P$ doesn't quantify $x$ either existentially or universally. \newline{}$FV\kern-2pt\left(P\right)$ is the set of all \index{free variable}free variables in an expression $P$. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:modify}}\\\label{definition:modify}A program $A$ is said to \index{modify}\textbf{modify} a variable $x$ if at any point, $A$ assigns to $x$. \newline{}$modifies\kern-2pt\left(A\right)$ is the set of all variables that $A$ modifies. \end{de}\begin{de}The \index{rule of constancy}\textbf{rule of constancy} is an \index{inference}inference in Hoare Logic. Let $R$ be an assertion. \[\infer{\left\{P\wedge{}R\right\}\,A\,\left\{Q\wedge{}R\right\}}{\left\{P\right\}\,A\,\left\{Q\right\},\,FV\kern-2pt\left(R\right)\cap{}modifies\kern-2pt\left(A\right)\underset{set}{=}\emptyset{}}\]This is known as ``Whatever $A$ doesn't modify, stays the same. ''. \end{de}\begin{ex}\[\infer{\left\{x=0\wedge{}y=3\right\}\,x:=x+1\,\left\{x=1\wedge{}y=3\right\}}{\left\{x=0\right\}\,x:=x+1\,\left\{x=1\right\},\,FV\kern-2pt\left(y=3\right)\cap{}modifies\kern-2pt\left(x:=x+1\right)\underset{set}{=}\emptyset{}}\]\end{ex}\begin{ex}\[\infer{\left\{x=4\wedge{}y=3\right\}\,x:=\sqrt{y}\,\left\{z=2\wedge{}y=3\right\}}{\left\{x=4\right\}\,x:=\sqrt{y}\,\left\{z=2\right\},\,FV\kern-2pt\left(y=3\right)\cap{}modifies\kern-2pt\left(x:=\sqrt{y}\right)\underset{set}{=}\emptyset{}}\]\end{ex}\todo[color=red,inline,size=\small]{The assignment axiom for arrays}\begin{de}The \index{conditional rule}\textbf{conditional rule} is an \index{inference}inference in Hoare Logic. \[\infer{\left\{P\right\}\,\text{\textbf{if }}c\text{\textbf{ then }}A\text{\textbf{ else }}B\text{\textbf{ end}}\,\left\{Q\right\}}{\left\{P\wedge{}c\right\}\,A\,\left\{Q\right\},\,\left\{P\wedge{}\neg{}c\right\}\,B\,\left\{Q\right\}}\]\end{de}\begin{ex}\[\infer{\left\{y>0\right\}\,\text{\textbf{if }}x>0\text{\textbf{ then }}y:=y+x\text{\textbf{ else }}y:=y-x\text{\textbf{ end}}\,\left\{y>0\right\}}{\left\{y>0\wedge{}x>0\right\}\,y:=y+x\,\left\{y>0\right\},\,\left\{y>0\wedge{}\neg{}\left(x>0\right)\right\}\,y:=y-x\,\left\{y>0\right\}}\]\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:loop-rule}}\\\label{definition:loop-rule}The \index{loop rule}\textbf{loop rule} is an \index{inference}inference in Hoare Logic. \[\infer{\left\{P\right\}\,\text{\textbf{from }}A\text{\textbf{ until }}c\text{\textbf{ loop }}B\text{\textbf{ end}}\,\left\{i\wedge{}c\right\}}{\left\{P\right\}\,A\,\left\{i\right\},\,\left\{i\wedge{}\neg{}c\right\}\,B\,\left\{i\right\}}\]The first triple is called the \index{initiation}\textbf{initiation} and  the second is called the \index{consecution}\textbf{consecution} or \index{inductiveness}\textbf{inductiveness}. This rule is also sometimes written as follows. 
\begin{prooftree}\AxiomC{$\left\{P\right\}\,A\,\left\{i\right\}$}\AxiomC{$\left\{i\wedge{}\neg{}c\right\}\,B\,\left\{i\right\}$}\AxiomC{$i\wedge{}c\Rightarrow{}Q$}\LeftLabel{[loop]}\TrinaryInfC{$\left\{P\right\}\,\text{\textbf{from }}A\text{\textbf{ until }}c\text{\textbf{ loop }}B\text{\textbf{ end}}\,\left\{Q\right\}$}\end{prooftree}
\end{de}\begin{ex}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{example:loop-rule-example}}\\\label{example:loop-rule-example}\[\infer{\left\{y>3\wedge{}n>0\right\}\,\text{\textbf{from }}i:=0\text{\textbf{ until }}i=n\text{\textbf{ loop }}\begin{array}{l}i:=i+1\\y:=y+1\\\end{array}\text{\textbf{ end}}\,\left\{y>3+n\right\}}{\left\{y>3\wedge{}n>0\right\}\,i:=0\,\left\{y>3+i\right\},\,\left\{y>3+i\wedge{}\left(\neg{}i=n\right)\right\}\,\begin{array}{l}i:=i+1\\y:=y+1\\\end{array}\,\left\{y>3+i\right\},\,\left(y>3+i\wedge{}i=n\right)\Rightarrow{}y>3+n}\]\end{ex}\todo[color=red,inline,size=\small]{Loop rule with do while instead of just while.}\subsection{Termination}To show total correctness, rather than just partial correctness, termination must also be proven. Termination is asserted for all but the loop triples if all the antecedents terminate. \begin{de}To prove the total correctness of a loop triple, we must first prove partial correctness and then loop termination as follows. There must exist a set $S$ with a total ordering $\leq{}$ such that $S$ has a least element $\bot{}$ with respect to $\leq{}$. Three more conditions must hold. \begin{enumerate}\item{}$\left\{P\right\}\,A\,\left\{v\geq{}\bot{}\right\}$\item{}$\left\{v\geq{}\bot{}\right\}$ is an invariant of the loop. \[\left\{v\geq{}\bot{}\right\}\,A\,\left\{v\geq{}\bot{}\right\}\]\item{}$v$ decreases with ever iteration. \[\forall{}v':\ v<v'\Rightarrow{}\left\{v=v'\wedge{}\neg{}c\right\}\,B\,\left\{v<v'\right\}\]\end{enumerate}\end{de}\begin{ex}This program is totally correct. \[\left\{y>3\wedge{}n>0\right\}\,\text{\textbf{from }}i:=0\text{\textbf{ until }}i=n\text{\textbf{ loop }}\begin{array}{l}i:=i+1\\y:=y+1\\\end{array}\text{\textbf{ end}}\,\left\{y>3+n\right\}\]\begin{proof}Partial correctness was already proven in an earlier example\footnote{See example \ref{example:loop-rule-example} on page \pageref{example:loop-rule-example}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{example:loop-rule-example}}}. Only termination is left to prove. Let $\left(n-i\right)$ be the variant of the loop. \begin{itemize}\item{}The variant stays positive after initialization. \[\left\{y>3\wedge{}n>0\right\}\,i:=0\,\left\{\left(n-i\right)\geq{}0\right\}\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\item{}$\left\{\left(n-i\right)\geq{}0\right\}$ is an invariant of the loop. \[\left\{\left(n-i\right)\geq{}0\right\}\,\begin{array}{l}i:=i+1\\y:=y+1\\\end{array}\,\left\{\left(n-i\right)\geq{}0\right\}\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\item{}$\left(n-i\right)$ decreases with ever iteration. \[\forall{}v':\ \left(n-i\right)<v'\Rightarrow{}\left\{\left(n-i\right)=v'\wedge{}\neg{}c\right\}\,B\,\left\{\left(n-i\right)<v'\right\}\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{itemize}\end{proof}\end{ex}\begin{ex}The following \index{Hoare triple}Hoare triple is true. \[\left\{x>0\right\}\,x:=x+1;\ \index{skip}skip\,\left\{x>1\right\}\]\begin{proof}\begin{prooftree}\AxiomC{}\LeftLabel{[ass]}\UnaryInfC{$\left\{x+1>1\right\}\,x:=x+1\,\left\{x>1\right\}$}\AxiomC{}\LeftLabel{[EM]}\UnaryInfC{$x>0\Rightarrow{}x+1>1$}\LeftLabel{[conseq]}\BinaryInfC{$\left\{x>0\right\}\,x:=x+1\,\left\{x>1\right\}$}\AxiomC{}\LeftLabel{[skip]}\UnaryInfC{$\left\{x>1\right\}\,\index{skip}skip\,\left\{x>1\right\}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\left\{x>0\right\}\,x:=x+1;\ \index{skip}skip\,\left\{x>1\right\}$}\end{prooftree}\end{proof}\end{ex}\nocite{software-verification-axiomatic-semantics-part1}\begin{ex}\textbf{Exam Question: Software Verification @ ETH, December 2014}\newline{}The following \index{Hoare triple}Hoare triple represents a partially correct program. \[\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\begin{array}{l}\text{\textbf{from}}\\\quad{}\,k:=0\\\text{\textbf{until }}\,k=n\text{\textbf{ loop}}\\\quad{}\begin{array}{l}\begin{array}{l}\text{\textbf{if }}\,k\text{ mod }3=0\\\text{\textbf{then}}\\\quad{}b\left[k\right]:=a\left[k\right]+1\\\text{\textbf{end}}\\\end{array}\\\,k:=k+1\\\end{array}\\\text{\textbf{end}}\\\end{array}\\\left\{\forall{}i:\ \left(\left(0\leq{}i<n\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}\]\begin{proof}The tree for this proof would be large enough to fill an A2 or even an A1 page and must therefore be broken down. The first thing to do for a loop like this, is to find an invariant of the loop. It needs to be strong enough to, in conjunction with the guard, imply the postcondition. A good first suggestion could be the following. \[Inv=\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]Now that we have a loop invariant, we can use the \index{loop rule}loop rule\footnote{See definition \ref{definition:loop-rule} on page \pageref{definition:loop-rule}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:loop-rule}}} to prove this Hoare triple. This means that we now have three smaller parts to prove. \begin{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\,k:=0\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}The rule of conjunction allows us to split this up again. \begin{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\\\end{array}\]\end{mdframed}We will use the assignment axiom schema to prove this triple. The following hoare triple is an instance of the assignment axiom schema. \begin{prooftree}\AxiomC{}\LeftLabel{[ass]}\UnaryInfC{$\begin{array}{c}\left\{\forall{}i:\ \left(\left(0\leq{}i<0\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\\\end{array}$}\end{prooftree}It's precondition can be rewritten as follows. \[\forall{}i:\ \left(\left(0\leq{}i<0\right)\Rightarrow{}a\left[i\right]=0\right)\Leftrightarrow{}\forall{}i:\ \left(false\Rightarrow{}a\left[i\right]=0\right)\Leftrightarrow{}true\]Thus we have the following triple. \[\left\{true\right\}\,\,k:=0\,\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\]Because anything implies true, we can use the rule of consequence\footnote{See figure \ref{figure:fig:consequence-in-this-exam-thingy1} on page \pageref{figure:fig:consequence-in-this-exam-thingy1}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy1}}}. \begin{sidewaysfigure}[!p]\centering{}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{true\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\\\end{array}$}\AxiomC{$\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\Rightarrow{}true$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right\}\\\end{array}$}\end{prooftree}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy1}}\\\label{figure:fig:consequence-in-this-exam-thingy1}\caption{Application of the rule of consequence}\end{sidewaysfigure}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}\]\end{mdframed}Analogous to the previous point, the assignment axiom schema gives us this triple. \begin{prooftree}\AxiomC{}\LeftLabel{[ass]}\UnaryInfC{$\begin{array}{c}\left\{\forall{}i:\ \left(\left(0\leq{}i<0\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}$}\end{prooftree}The precondition can again be rewritten as $true$. \begin{align*}\forall{}i:\ \left(\left(0\leq{}i<0\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)&\Leftrightarrow{}\forall{}i:\ \left(false\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\ & \Leftrightarrow{}\forall{}i:\ \left(false\Rightarrow{}\left(b\left[i\right]=1\right)\right)\\ & \Leftrightarrow{}true\end{align*}This gives us the following triple. \[\left\{true\right\}\,\,k:=0\,\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\]Once more we use the rule of consequence to use this triple to proof the given triple\footnote{See figure \ref{figure:fig:consequence-in-this-exam-thingy2} on page \pageref{figure:fig:consequence-in-this-exam-thingy2}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2}}}. \begin{sidewaysfigure}[!p]\centering{}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{true\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}$}\AxiomC{$\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\Rightarrow{}true$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{\left(n>0\right)\wedge{}\left(\forall{}i:\ \left(0\leq{}i<n\right)\Rightarrow{}\left(a\left[i\right]=b\left[i\right]=0\right)\right)\right\}\\\,k:=0\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}$}\end{prooftree}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2}}\\\label{figure:fig:consequence-in-this-exam-thingy2}\caption{Application of the rule of consequence}\end{sidewaysfigure}\end{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\end{array}\right\}\\\begin{array}{l}\begin{array}{l}\text{\textbf{if }}\,k\text{ mod }3=0\\\text{\textbf{then}}\\\quad{}b\left[k\right]:=a\left[k\right]+1\\\text{\textbf{end}}\\\end{array}\\\,k:=k+1\\\end{array}\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}Here we use the rule of sequenctial composition to split this up into two parts. We'll use the following inbetween-assertion. \[\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]\begin{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\end{array}\right\}\\\begin{array}{l}\text{\textbf{if }}\,k\text{ mod }3=0\\\text{\textbf{then}}\\\quad{}b\left[k\right]:=a\left[k\right]+1\\\text{\textbf{end}}\\\end{array}\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}First we apply the conditional rule to this if-then-else construction to split it up into two parts. \begin{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\end{array}\right\}\\b\left[k\right]:=a\left[k\right]+1\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}We'll first have to rewrite the postcondition to get some concretisation of the universal quantifier. \[\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\end{array}\right\}\\b\left[k\right]:=a\left[k\right]+1\\\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}b\left[k\right]=1\\\end{array}\right\}\\\end{array}\]The assignment axiom then gets us the following. \begin{prooftree}\AxiomC{}\LeftLabel{[ass]}\UnaryInfC{$\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\\\end{array}\right\}\\b\left[k\right]:=a\left[k\right]+1\\\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}b\left[k\right]=1\\\end{array}\right\}\\\end{array}$}\end{prooftree}Now we only have to prove that the precondition of the original triple implies the precondition of the second and apply the rule of consequence. \[\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\Rightarrow{}\\\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\\\end{array}\\\end{array}\]The first element in the conjunction at the conclusion can be omitted because they are in the hypothesis. \[\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\Rightarrow{}\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\\\end{array}\]We can intuitively see that in the conjunction of the precondition, the second an fourth elements imply the first element of the postcondition ... \[\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\wedge{}\,k\text{ mod }3=0\\\Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]... and the fourth elemnt implies the second element of the postcondition by itself. \[\,k\text{ mod }3=0\Rightarrow{}\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\]\todo[color=red,inline,size=\small]{Can this be more rigorous?}The rule of consequence can now be used to prove this triple\footnote{See figure \ref{figure:fig:consequence-in-this-exam-thingy2b} on page \pageref{figure:fig:consequence-in-this-exam-thingy2b}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2b}}}. \begin{sidewaysfigure}[!p]\centering{}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\\\end{array}\right\}\\b\left[k\right]:=a\left[k\right]+1\\\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}b\left[k\right]=1\\\end{array}\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\Rightarrow{}\\\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\left(k\text{ mod }3=0\right)\Rightarrow{}a\left[k\right]+1=1\\\end{array}\\\end{array}$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3=0\\\end{array}\right\}\\b\left[k\right]:=a\left[k\right]+1\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}$}\end{prooftree}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2b}}\\\label{figure:fig:consequence-in-this-exam-thingy2b}\caption{Application of the rule of consequence}\end{sidewaysfigure}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\end{array}\right\}\\\index{skip}skip\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}To prove this triple, we have to prove that the precondition implies the postcondition and then apply the rule of consequence to the skip axiom schema. The first part of the postcondition can be imediately asserted as it is part of a conjunction in the precondition. \[\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\end{array}\]Left to prove is now the following implication. \[\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]The only difference is in the hypothesis of the second implication. If we strip the unnecessary as follows, it becomes intuitively clear that this implication holds. \[\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\wedge{}\,k\text{ mod }3\not=0\\\Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]\todo[color=red,inline,size=\small]{can this be done more rigorously?}The rule of consequence can now be used to prove this triple\footnote{See figure \ref{figure:fig:consequence-in-this-exam-thingy2c} on page \pageref{figure:fig:consequence-in-this-exam-thingy2c}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2c}}}. \begin{sidewaysfigure}[!p]\centering{}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\end{array}\right\}\\\index{skip}skip\\\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\end{array}\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\end{array}\\\Rightarrow{}\\\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\end{array}$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,k\not=n\\\wedge{}\,k\text{ mod }3\not=0\\\end{array}\right\}\\\index{skip}skip\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}$}\end{prooftree}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy2c}}\\\label{figure:fig:consequence-in-this-exam-thingy2c}\caption{Application of the rule of consequence}\end{sidewaysfigure}\end{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\,k:=k+1\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}\]\end{mdframed}First we'll use the rule of constancy to get rid of the first part of each condition\footnote{See figure \ref{figure:fig:consequence-in-this-exam-thingy3} on page \pageref{figure:fig:consequence-in-this-exam-thingy3}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy3}}}. \begin{sidewaysfigure}[!p]\centering{}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\,k:=k+1\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}FV\kern-2pt\left(\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\right)\\\cap{}\\modifies\kern-2pt\left(\,k:=k+1\right)\\\underset{set}{=}\emptyset{}\\\end{array}$}\LeftLabel{[const]}\BinaryInfC{$\begin{array}{c}\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\,k:=k+1\\\left\{\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\right\}\\\end{array}$}\end{prooftree}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{figure:fig:consequence-in-this-exam-thingy3}}\\\label{figure:fig:consequence-in-this-exam-thingy3}\caption{Application of the rule of constancy}\end{sidewaysfigure}This leaves us with the following triple to prove. \[\begin{array}{c}\left\{\forall{}i:\ \left(\left(0\leq{}i<k+1\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\,k:=k+1\\\left\{\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\right\}\\\end{array}\]This is an instantiation of the assignment axiom schema. \end{enumerate}\item{}\noindent{}\begin{mdframed}\[\begin{array}{c}\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\\\wedge{}\forall{}i:\ \left(\left(0\leq{}i<k\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\\\wedge{}\,\,k=n\\ \Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<n\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]\end{mdframed}Simply replacing $k$ by $n$ in the hypothesis, gets us this implication. \[\begin{array}{c}\forall{}i:\ \left(\left(0\leq{}i<k\right)\Rightarrow{}a\left[i\right]=0\right)\wedge{}\forall{}i:\ \left(\left(0\leq{}i<n\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\ \Rightarrow{}\forall{}i:\ \left(\left(0\leq{}i<n\right)\wedge{}\left(i\text{ mod }3=0\right)\right)\Rightarrow{}\left(b\left[i\right]=1\right)\\\end{array}\]This is of the form $P\wedge{}Q\Rightarrow{}Q$ and is therefore clearly true. \end{enumerate}\end{proof}\end{ex}\section{Separation Logic}\subsection{Predicates}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:heap}}\\\label{definition:heap}A \index{heap}\textbf{heap} is a partial function from a set of locations (pointers) to values. The difference between a \index{heap}heap and a program state is that values on the heap can represent other locations on the heap. In this new model, variables will evaluate to locations. The \index{heap}heap will then tell us what the value is that is stored at that location. \end{de}\begin{nte}Watch out, this means that variables aren't stored like they were before, now only references to variables are kept in the store. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:separation-logic}}\\\label{definition:separation-logic}\index{Separation logic}\textbf{Separation logic} is an extension to \index{Hoare logic}Hoare logic\footnote{See definition \ref{definition:hoare-logic} on page \pageref{definition:hoare-logic}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:hoare-logic}}} that facilitates local reasoning. \index{Separation logic}Separation logic offers spatial connectives that allow for more modular reasoning. In \index{Separation logic}Separation logic program states comprise of both a variable store and a heap. \end{de}\begin{de}Assertion satisfaction needs to be redefined in \index{Separation logic}Separation logic to incorporate the heap. The expression that represents ``A program state $s$, together with a heap $h$, \index{satisfies}\textbf{satisfies} an \index{assertion}assertion $P$. '' is de:: Noted as $s, h\vDash{}P$. It is inductively defined as follows. \begin{itemize}\item{}$s, h\vDash{}false$ never holds. \item{}$s, h\vDash{}true$ always holds. \item{}$s, h\vDash{}P\wedge{}Q\Leftrightarrow{}s, h\vDash{}P\wedge{}s, h\vDash{}Q$\item{}$s, h\vDash{}P\vee{}Q\Leftrightarrow{}s, h\vDash{}P\vee{}s, h\vDash{}Q$\item{}$s, h\vDash{}P\Rightarrow{}Q\Leftrightarrow{}s, h\vDash{}P\Rightarrow{}s, h\vDash{}Q$\item{}$s, h\vDash{}e=f\Leftrightarrow{}{\left[|e|\right]}_{s}={\left[|f|\right]}_{s}$\end{itemize}\end{de}\begin{de}$emp$ represents the assertion that the heap is empty. $s, h\vDash{}emp\Leftrightarrow{}h\underset{set}{=}\emptyset{}$\end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/107649f205a9717d.eps}\caption{A situation in which $emp$ holds. }\end{figure}\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:points-to}}\\\label{definition:points-to}$s, h\vDash{}e\mapsto{}f\Leftrightarrow{}\left\{{\left[|e|\right]}_{s}\mapsto{}{\left[|f|\right]}_{s}\right\}\in{}h$... or informally: ``There exists a value $f$ on the heap that $e$ (which may also be a value on the heap) points to and no others. ''. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/9f727bbb64516f94.eps}\caption{A situation in which $e\mapsto{}8$ holds. }\end{figure}\end{ex}\begin{de}$s, h\vDash{}P*Q\Leftrightarrow{}\exists{}{h}_{1}, {h}_{2}:\ {h}_{1}\bot{}{h}_{2}\wedge{}{h}_{1}\circ{}{h}_{2}=h\wedge{}s, {h}_{1}\vDash{}P\wedge{}s, {h}_{2}\vDash{}Q$... or informally: ``The heap can be divided into two parts ${h}_{1}$ and ${h}_{2}$, one where $s, {h}_{1}\vDash{}P$ holds and one where $s, {h}_{2}\vDash{}Q$. ''. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/88773c76fc9f7e96.eps}\caption{A situation in which $s, h\vDash{}x\mapsto{}5*5\mapsto{}z*z\mapsto{}10$ holds. }\end{figure}\end{ex}\begin{thm}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{theorem:empty-heap-separating-conjunction}}\\\label{theorem:empty-heap-separating-conjunction}The empty heap can be separatingly conjuncted with any assertion. \[P\Rightarrow{}P*emp\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{de}The notation $e\mapsto{}{f}_{0}, {f}_{1}, \dotsc{}, {f}_{n}$ is a shorthand for the following. \[e\mapsto{}{f}_{0}*e+1\mapsto{}{f}_{1}*\dotsc{}*e+n\mapsto{}{f}_{n}\]\end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/43b26bcc78530c9f.eps}\caption{A situation in which $e\mapsto{}1, 5$ holds. }\end{figure}\end{ex}\begin{de}$s, h\vDash{}P\rightarrow{}\kern-8pt*Q$ is said to hold if and only if ``Extending $h$ with a disjoint part $h'$ that satisfies $P$ results in a new heap satisfying $Q$. ''. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.3333333333333333\textwidth{}]{/tmp/c562160a21fc31b4.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.3333333333333333\textwidth{}]{/tmp/b65bea329852db2a.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.3333333333333333\textwidth{}]{/tmp/c1684d1e2f81f1ca.eps}\caption{}\end{figure}The first situation is an example of a situation in which $s, h\vDash{}\left(x\mapsto{}5\right)\rightarrow{}\kern-8pt*\left(x\mapsto{}5*y\mapsto{}6\right)$ holds.. This assertion holds because the heap could be extended with the disjunct heap from the second situation to produce a heap (the one on the right), that satisfies $x\mapsto{}5*y\mapsto{}6$. \end{ex}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/c33d07de8bff20fa.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/26b61268bedf6281.eps}\caption{Two situations $A$ on the left and $B$ on the right. }\end{figure}\begin{figure}[H]\centering{}$\begin{array}[c]{|c|c|c|c|c|}\hline &A&B\\\hline \hline x\mapsto{}6, 7&false&true\\\hline x\mapsto{}6, 7*true&true&true\\\hline x\mapsto{}6, 7*y\mapsto{}6, 7&true&true\\\hline x\mapsto{}6, 7\wedge{}y\mapsto{}6, 7&false&true\\\hline \left(x\mapsto{}6, 7*true\right)\wedge{}\left(y\mapsto{}6, 7*true\right)&true&true\\\hline \end{array}$\caption{Assertions on the situations}\end{figure}The first assertion doesn't hold for situation $A$ because there are more elements on the heap than just the two mentioned in $x\mapsto{}4, 4$. The third assertion doesn't hold for situation $B$ because the heap cannot be divided into two parts. The fourth assertion doesn't hold for situation $A$ because there are too many elements on the heap. \end{ex}\begin{ex}\textbf{Exam Question: Software Verification @ ETH, December 2014}\newline{}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/6982c0f9b3e80fd0.eps}\caption{A situation in which $x\mapsto{}6, 7*\neg{}\left(x\mapsto{}6, 7\right)$ holds. }\end{figure}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/26b61268bedf6281.eps}\caption{A situation in which $x\mapsto{}6, 7\wedge{}y\mapsto{}6, 7$ holds. }\end{figure}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/39d4727c47ee1f45.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/7c7198a9c73fc215.eps}\caption{Two situations in which $emp\Rightarrow{}x=y$ holds. }\end{figure}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/548f850015b9aab0.eps}\caption{A situation in which $\exists{}i:\ x\mapsto{}i*i\mapsto{}i$ holds. }\end{figure}\end{ex}\begin{ex}\textbf{Exam Question: Software Verification @ ETH, December 2013}\newline{}A well-formed binary tree $t$ is defined by the following grammar. \[t\quad{}\equiv{}\quad{}n\mid{}\left({t}_{1}, {t}_{2}\right)\]These symbols have the following semantics. \begin{itemize}\item{}$tree\kern-2pt\left(n, i\right)\Leftrightarrow{}i\mapsto{}n$\item{}$tree\kern-2pt\left(\left({t}_{1}, {t}_{2}\right), i\right)\Leftrightarrow{}\exists{}l, r:\ i\mapsto{}l, r*tree\kern-2pt\left({t}_{1}, l\right)*tree\kern-2pt\left({t}_{2}, r\right)$\end{itemize}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/ea596c0c1ffc5c82.eps}\caption{An example of a situation in which $tree\kern-2pt\left(\left(7, 8\right), x\right)$ holds. }\end{figure}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/90c205826216457e.eps}\caption{An example of a situation in which $tree\kern-2pt\left(5, x\right)\wedge{}tree\kern-2pt\left(5, y\right)$ holds. }\end{figure}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/a900b54ff850b864.eps}\caption{An example of a situation in which $tree\kern-2pt\left(\left(\left(3, 2\right), 1\right), x\right)$ holds. }\end{figure}\end{ex}\subsection{Heap operations}\begin{de}${\left[e\right]}_{h}$ represents the location of the variable that is said to be stored in $e$. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/edf878da73d4105e.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/c7568f81eef0a974.eps}\caption{An example situation before and after a $x:={\left[y\right]}_{h}$ assignment. }\end{figure}Note that this example is slightly misleading because the variable stored in y is a value and not a pointer. The next example should clear up the confusion. \end{ex}\begin{ex}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/782b09917bbb7574.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/26f753400b91f675.eps}\caption{An example situation before and after a $x:={\left[y\right]}_{h}$ assignment. }\end{figure}\end{ex}\begin{de}${\left[e\right]}_{h}:=f$ represents the instruction to assign the value of $f$ as the contents of ${\left[e\right]}_{h}$ on the heap. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/d8483cbd80864ce6.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/6baaaf592262e3fc.eps}\caption{An example situation before and after a ${\left[x+1\right]}_{h}:=y$ instruction. }\end{figure}\end{ex}\begin{de}$cons\kern-2pt\left({e}_{1}, \dotsc{}, {e}_{n}\right)$ represents the instruction to allocate $n$ consecutive locations that are not in the heap yet, say ${l}_{1}, \dotsc{}, {l}_{n}$ and assign the values of ${e}_{1}, \dotsc{}, {e}_{n}$ to the contents of ${l}_{1}, \dotsc{}, {l}_{n}$ respectively. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/712f99430d7fd2cc.eps}\caption{The result of $x:=cons\kern-2pt\left(1, 2, 5\right)$ starting from an empty heap. }\end{figure}\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:disposal}}\\\label{definition:disposal}$dispose\kern-2pt\left(e\right)$ represents the instruction to fetch $e$ to get its location $l$ and remove $l$ from the heap. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/471342486add5aac.eps}\hspace{0.50000cm}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/662134c7055591c1.eps}\caption{An example situation before and after a $dispose\kern-2pt\left(x\right)$ instruction. }\end{figure}\end{ex}\begin{ex}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{example:separation-logic-example-program}}\\\label{example:separation-logic-example-program}In this example, we'll look at the following simple program and what it does to its store/heap situation. \[\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\y:={\left[y\right]}_{h}\\\end{array}\]Starting from an empty heap, after the first two instructions the situation will be as follows. \noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/830f5f1a16e58e1a.eps}\caption{}\end{figure}The following two instructions leave the situation as follows. \noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/faee018dc0856adc.eps}\caption{}\end{figure}After the fifth instruction, the situation looks as follows. \noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/bdc5a020660859d7.eps}\caption{}\end{figure}The dispose instruction disposes of some allocated heap space but there still exist pointers to it. \noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/e64504cb2c83255e.eps}\caption{}\end{figure}Lastly, the last instruction leaves the heap as follows. \noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.25\textwidth{}]{/tmp/84f3d265e63310ec.eps}\caption{}\end{figure}\end{ex}\subsection{Axioms and inference rules}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:heap-mutation}}\\\label{definition:heap-mutation}$\left\{e\mapsto{}x\right\}\,{\left[e\right]}_{h}:=f\,\left\{e\mapsto{}f\right\}$ is an \index{axiom schema}axiom schema in \index{Separation logic}Separation logic. This is called the \index{heap mutation}\textbf{heap mutation} \index{axiom schema}axiom schema. \end{de}\begin{de}$\left\{e\mapsto{}x\right\}\,dispose\kern-2pt\left(e\right)\,\left\{emp\right\}$ is an \index{axiom schema}axiom schema in \index{Separation logic}Separation logic. \end{de}\begin{de}$\left\{X=x\wedge{}e\mapsto{}Y\right\}\,x:={\left[e\right]}_{h}\,\left\{e\left[X / x\right]\mapsto{}Y\wedge{}Y=x\right\}$ is an \index{axiom schema}axiom schema in \index{Separation logic}Separation logic. \newline{}It means ``If we know that a variable $x$ has location $X$ and a expression $e$ points to a value $Y$ then, after we assign the location of $e$ to $x$, we know that the expression $e$ with all $X$'s replaced by $x$ will now point to the value $Y$ and that $x$ now has location $Y$. ''. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:allocation}}\\\label{definition:allocation}$\left\{emp\right\}\,x:=cons\kern-2pt\left({e}_{0}, \dotsc{}, {e}_{n}\right)\,\left\{x\mapsto{}{e}_{0}, \dotsc{}, {e}_{n}\right\}$ is an \index{axiom schema}axiom schema in \index{Separation logic}Separation logic. Note that $x$ must not appear in any of ${e}_{0}, \dotsc{}, {e}_{n}$. This is called the \index{allocation}\textbf{allocation} \index{axiom schema}axiom schema. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:frame-rule}}\\\label{definition:frame-rule}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:frame}}\\\label{definition:frame}The \index{frame rule}\textbf{frame rule} is the most important rule in \index{Separation logic}Separation logic. \begin{prooftree}\AxiomC{$\left\{P\right\}\,C\,\left\{Q\right\}$}\LeftLabel{[frame]}\UnaryInfC{$\left\{P*r\right\}\,C\,\left\{Q*r\right\}$}\end{prooftree}Here, $r$ is called the \index{frame}\textbf{frame}. Note that no variable modified by $C$ may appear free in $r$. \end{de}\begin{de}The interpretation of a triple in \index{Separation logic}Separation logic needs to be extended from its interpretation in \index{Hoare logic}Hoare logic. In \index{Separation logic}Separation logic a triple $\left\{P\right\}\,C\,\left\{Q\right\}$ means ``If $C$ is executed on a state satisfying $P$ then it will not fault, and if it terminates, that state will satisfy $Q$ afterwards. ''. \end{de}\begin{ex}Retaking the program from an earlier example\footnote{See example \ref{example:separation-logic-example-program} on page \pageref{example:separation-logic-example-program}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{example:separation-logic-example-program}}}, we will now prove the following triple. \[\left\{emp\right\}\,\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\y:={\left[y\right]}_{h}\\\end{array}\,\left\{y\mapsto{}4*true\right\}\]In \index{Separation logic}Separation logic proofs we reason forwards rather than backwards like in \index{Hoare logic}Hoare logic. We start with an empty heap and see the first instruction: $x:=cons\kern-2pt\left(3, 3\right)$. Applying the \index{allocation}allocation \index{axiom schema}axiom schema gets us the following triple. \[\left\{emp\right\}\,x:=cons\kern-2pt\left(3, 3\right)\,\left\{x\mapsto{}3, 3\right\}\]We get something similar by applying the same axiom schema to the second instruction. \[\left\{emp\right\}\,y:=cons\kern-2pt\left(4, 4\right)\,\left\{y\mapsto{}4, 4\right\}\]But now these need to be combined before we can go on. Note first that we can separatingly conjoin an empty heap to the postcondition of the first triple as follows\footnote{See theorem \ref{theorem:empty-heap-separating-conjunction} on page \pageref{theorem:empty-heap-separating-conjunction}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{theorem:empty-heap-separating-conjunction}}}. \[x\mapsto{}3, 3\Rightarrow{}x\mapsto{}3, 3*emp\]We can then apply the rule of \index{consequence}consequence\footnote{See definition \ref{definition:consequence} on page \pageref{definition:consequence}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:consequence}}}. \begin{prooftree}\AxiomC{$\left\{emp\right\}\,x:=cons\kern-2pt\left(3, 3\right)\,\left\{x\mapsto{}3, 3\right\}$}\AxiomC{$x\mapsto{}3, 3\Rightarrow{}x\mapsto{}3, 3*emp$}\LeftLabel{[conseq]}\BinaryInfC{$\left\{emp\right\}\,x:=cons\kern-2pt\left(3, 3\right)\,\left\{x\mapsto{}3, 3*emp\right\}$}\end{prooftree}Now we can use the \index{frame rule}frame rule to the second triple we found with $x\mapsto{}3, 3$ as a frame. \begin{prooftree}\AxiomC{$\left\{emp\right\}\,y:=cons\kern-2pt\left(4, 4\right)\,\left\{y\mapsto{}4, 4\right\}$}\LeftLabel{[frame]}\UnaryInfC{$\left\{x\mapsto{}3, 3*emp\right\}\,y:=cons\kern-2pt\left(4, 4\right)\,\left\{y\mapsto{}4, 4*x\mapsto{}3, 3\right\}$}\end{prooftree}Finally we can use the rule of \index{sequential composition}sequential composition\footnote{See definition \ref{definition:sequential-composition} on page \pageref{definition:sequential-composition}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:sequential-composition}}} to combine the first two instructions. \begin{prooftree}\AxiomC{$\left\{emp\right\}\,x:=cons\kern-2pt\left(3, 3\right)\,\left\{x\mapsto{}3, 3*emp\right\}$}\AxiomC{$\left\{x\mapsto{}3, 3*emp\right\}\,y:=cons\kern-2pt\left(4, 4\right)\,\left\{y\mapsto{}4, 4*x\mapsto{}3, 3\right\}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\left\{emp\right\}\,\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\\end{array}\,\left\{y\mapsto{}4, 4*x\mapsto{}3, 3\right\}$}\end{prooftree}The next two instructions give us similar triples using the \index{heap mutation}heap mutation \index{axiom schema}axiom schema. \[\left\{x+1\mapsto{}3\right\}\,{\left[x+1\right]}_{h}:=y\,\left\{x+1\mapsto{}y\right\}\]\[\left\{y+1\mapsto{}4\right\}\,{\left[y+1\right]}_{h}:=x\,\left\{y+1\mapsto{}x\right\}\]We can apply the frame rule with frame $y\mapsto{}4, 4*x\mapsto{}3$. \begin{prooftree}\AxiomC{$\left\{x+1\mapsto{}3\right\}\,{\left[x+1\right]}_{h}:=y\,\left\{x+1\mapsto{}y\right\}$}\LeftLabel{[frame]}\UnaryInfC{$\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}3\right\}\,{\left[x+1\right]}_{h}:=y\,\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}y\right\}$}\end{prooftree}Now we can add the third instruction to the list using the \index{sequential composition}sequential composition rule. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\\end{array}\\\left\{y\mapsto{}4, 4*x\mapsto{}3, 3\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}3\right\}\\{\left[x+1\right]}_{h}:=y\\\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}y\right\}\\\end{array}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\left\{emp\right\}\,\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\\end{array}\,\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}y\right\}$}\end{prooftree}Analogously we can use the frame rule with frame $x\mapsto{}3, y*y\mapsto{}4$ and another application of sequential composition to move forward another instruction. \begin{prooftree}\AxiomC{$\left\{y+1\mapsto{}4\right\}\,{\left[y+1\right]}_{h}:=x\,\left\{y+1\mapsto{}x\right\}$}\LeftLabel{[frame]}\UnaryInfC{$\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}4\right\}\,{\left[y+1\right]}_{h}:=x\,\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}x\right\}$}\end{prooftree}\begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\\end{array}\\\left\{y\mapsto{}4, 4*x\mapsto{}3*x+1\mapsto{}y\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}4\right\}\\{\left[y+1\right]}_{h}:=x\\\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}x\right\}\\\end{array}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\left\{emp\right\}\,\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\\end{array}\,\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}x\right\}$}\end{prooftree}The forward assignment axiom schema\footnote{See definition \ref{definition:forward-assignment} on page \pageref{definition:forward-assignment}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:forward-assignment}}} gives us a triple concerning the fifth instruction. \[\left\{x\mapsto{}3, y*y\mapsto{}4, x\right\}\,y:=x+1\,\left\{\left(x\mapsto{}3, {y}^{old}*{y}^{old}\mapsto{}4, x\right)\wedge{}\left(y=x+1\right)\right\}\]Another application of the rule of \index{sequential composition}sequential composition adds the fifth instruction to the list. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\\end{array}\\\left\{x\mapsto{}3, y*y\mapsto{}4*y+1\mapsto{}x\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\left\{x\mapsto{}3, y*y\mapsto{}4, x\right\}\\y:=x+1\\\left\{\left(x\mapsto{}3, {y}^{old}*{y}^{old}\mapsto{}4, x\right)\wedge{}\left(y=x+1\right)\right\}\\\end{array}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\\end{array}\\\left\{\left(x\mapsto{}3, {y}^{old}*{y}^{old}\mapsto{}4, x\right)\wedge{}\left(y=x+1\right)\right\}\\\end{array}$}\end{prooftree}We use the \index{disposal}disposal \index{axiom schema}axiom schema to get a triple involving the sixth instruction. \[\left\{x\mapsto{}3\right\}\,dispose\kern-2pt\left(x\right)\,\left\{emp\right\}\]We use the \index{frame rule}frame rule with frame $x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1$ as follows. \begin{prooftree}\AxiomC{$\left\{x\mapsto{}3\right\}\,dispose\kern-2pt\left(x\right)\,\left\{emp\right\}$}\LeftLabel{[frame]}\UnaryInfC{$\left\{x\mapsto{}3*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\,dispose\kern-2pt\left(x\right)\,\left\{emp*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}$}\end{prooftree}The rule of consequence allows us to rewrite that postcondition because $emp*P$ implies $P$ for any $P$. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{x\mapsto{}3*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\dispose\kern-2pt\left(x\right)\\\left\{emp*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}x\mapsto{}3*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\\ \Rightarrow{} \\x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\\\end{array}$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{x\mapsto{}3*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\dispose\kern-2pt\left(x\right)\\\left\{x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\\end{array}$}\end{prooftree}Once more, the rule of sequential composition allows us to add an instruction to our list. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\\end{array}\\\left\{\left(x\mapsto{}3, {y}^{old}*{y}^{old}\mapsto{}4, x\right)\wedge{}\left(y=x+1\right)\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\left\{x\mapsto{}3*x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\dispose\kern-2pt\left(x\right)\\\left\{x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\\end{array}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\\end{array}\\\left\{x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\\end{array}$}\end{prooftree}The forward assignment axiom gets us another triple, this time concerning the seventh instruction. \[\begin{array}{c}\left\{x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{x+1={y}^{newold}\wedge{}{y}^{newold}\mapsto{}{y}^{old}\wedge{}y={\left[{y}^{newold}\right]}_{h}\right\}\\\end{array}\]The postcondition in this triple can be rewritten by implication. \[\begin{array}{c}x+1={y}^{newold}\wedge{}{y}^{newold}\mapsto{}{y}^{old}\wedge{}y={\left[{y}^{newold}\right]}_{h}\\\Rightarrow{}\\x+1={y}^{newold}\wedge{}{y}^{newold}\mapsto{}{y}^{old}\wedge{}y={y}^{old}\\\Rightarrow{}\\x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\\\end{array}\]The rule of consequence then gets us the according triple. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{x+1={y}^{newold}\wedge{}{y}^{newold}\mapsto{}{y}^{old}\wedge{}y={\left[{y}^{newold}\right]}_{h}\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}x+1={y}^{newold}\wedge{}{y}^{newold}\mapsto{}{y}^{old}\wedge{}y={\left[{y}^{newold}\right]}_{h}\\\Rightarrow{}\\x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\\\end{array}$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\end{prooftree}The frame rule now lets us add a frame: ${y}^{old}\mapsto{}4, x$. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\LeftLabel{[frame]}\UnaryInfC{$\begin{array}{c}\left\{{y}^{old}\mapsto{}4, x*x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{{y}^{old}\mapsto{}4, x*x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\end{prooftree}Finally we can use the rule of \index{sequential composition}sequential composition to get a triple about concerning the entire program. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\\end{array}\\\left\{x+1\mapsto{}{y}^{old}*{y}^{old}\mapsto{}4, x\wedge{}y=x+1\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}\left\{{y}^{old}\mapsto{}4, x*x+1=y\wedge{}y\mapsto{}{y}^{old}\right\}\\y:={\left[y\right]}_{h}\\\left\{{y}^{old}\mapsto{}4, x*x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\LeftLabel{[seqcomp]}\BinaryInfC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\y:={\left[y\right]}_{h}\\\end{array}\\\left\{{y}^{old}\mapsto{}4, x*x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\end{prooftree}One last application of the rule of \index{consequence}consequence completes the proof. \begin{prooftree}\AxiomC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\y:={\left[y\right]}_{h}\\\end{array}\\\left\{{y}^{old}\mapsto{}4, x*x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\right\}\\\end{array}$}\AxiomC{$\begin{array}{c}{y}^{old}\mapsto{}4, x*x+1\mapsto{}{y}^{old}\wedge{}y={y}^{old}\\\Rightarrow{}\\y\mapsto{}4*true\\\end{array}$}\LeftLabel{[conseq]}\BinaryInfC{$\begin{array}{c}\left\{emp\right\}\\\begin{array}{l}x:=cons\kern-2pt\left(3, 3\right)\\y:=cons\kern-2pt\left(4, 4\right)\\{\left[x+1\right]}_{h}:=y\\{\left[y+1\right]}_{h}:=x\\y:=x+1\\dispose\kern-2pt\left(x\right)\\y:={\left[y\right]}_{h}\\\end{array}\\\left\{y\mapsto{}4*true\right\}\\\end{array}$}\end{prooftree}\end{ex}\section{Temporal Logic}\subsection{Linear temporal logic}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:temporal-logic}}\\\label{definition:temporal-logic}\index{linear temporal logic}\textbf{linear temporal logic} is an extension of \index{Propositional logic}Propositional logic\footnote{See definition \ref{definition:propositional-logic} on page \pageref{definition:propositional-logic}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:propositional-logic}}} with temporal operators. Let $P$ be a fixed set of propositions. The \index{grammar}grammar of \index{linear temporal logic}linear temporal logic is defined as follow. \[p\mid{}\neg{}f\mid{}f\wedge{}g\mid{}f\vee{}g\mid{}\textbigcircle{}f\mid{}f\,\mathcal{U}\,g\]Here, $p$ is an atomic proposition from $P$. \begin{itemize}\item{}Next: $\textbigcircle{}f$. \item{}Until: $f\,\mathcal{U}\,g$. \end{itemize}There are also some shorthand notations excluding the propositional shorthands. \begin{itemize}\item{}Eventually: $\Diamond{}f\quad{}\equiv{}\quad{}true\,\mathcal{U}\,f$. \item{}Always: $\Box{}f\quad{}\equiv{}\quad{}\neg{}\Diamond{}\neg{}f$. \end{itemize}The semantics are defined as follows. In \index{linear temporal logic}linear temporal logic truth is evaluated with respect to a(n input) string. Let $w={w}_{1}{w}_{2}\dotsc{}{w}_{n}\in{}{P}^{*}$ be a string. $w$ satisfies a linear temporal logic \index{formula}formula $f$ at position $i$, de:: Noted as $w, i\vDash{}f$ under the following conditions. \begin{itemize}\item{}$w, i\vDash{}p\Leftrightarrow{}p={w}_{i}$\item{}$w, i\vDash{}\neg{}f\Leftrightarrow{}\neg{}w, i\vDash{}f$\item{}$w, i\vDash{}f\wedge{}g\Leftrightarrow{}\left(w, i\vDash{}f\wedge{}w, i\vDash{}g\right)$\item{}$w, i\vDash{}f\vee{}g\Leftrightarrow{}\left(w, i\vDash{}f\vee{}w, i\vDash{}g\right)$\item{}$w, i\vDash{}\textbigcircle{}f\Leftrightarrow{}\left(i<n\wedge{}w, i+1\vDash{}f\right)$\item{}$w, i\vDash{}f\,\mathcal{U}\,g\Leftrightarrow{}\left(\exists{}i, j:\ \left(i<j\leq{}n\right)\wedge{}w, j\vDash{}g\wedge{}\left(\forall{}k:\ \left(i\leq{}k<j\right)\Rightarrow{}w, k\vDash{}f\right)\right)$\end{itemize}\end{de}\begin{thm}Let $P$ be a fixed set of propositions. Let $w={w}_{1}{w}_{2}\dotsc{}{w}_{n}\in{}{P}^{*}$ be a string. The semantics of $w, i\vDash{}\Diamond{}f$ can be rewritten as follows. \[w, i\vDash{}\Diamond{}f=\exists{}i, j:\ \left(i\leq{}j\leq{}n\right)\wedge{}w, j\vDash{}f\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}Let $P$ be a fixed set of propositions. Let $w={w}_{1}{w}_{2}\dotsc{}{w}_{n}\in{}{P}^{*}$ be a string. The semantics of $w, i\vDash{}\Box{}f$ can be rewritten as follows. \[w, i\vDash{}\Box{}f=\forall{}i, j:\ \left(i\leq{}j\leq{}n\right)\Rightarrow{}w, j\vDash{}f\]\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{de}The \index{language}\textbf{language} of a \index{linear temporal logic}linear temporal logic \index{formula}formula is the sets of strings that satisfy the formula. \[{L}_{f}\quad{}\equiv{}\quad{}\left\{w\in{}{P}^{*}\mid{}w, 1\vDash{}f\right\}\]\end{de}\chapter{Computability}\section{Symbols and strings}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:symbol}}\\\label{definition:symbol}A \index{symbol}\textbf{symbol} is a representation of an abstract mathematical object.. The only prerequisite of a \index{symbol}symbol is that there is an equivalence relation $\underset{s}{=}$ defined on it. \todo[color=red,inline,size=\small]{There is a reference to ``equivalence relation'' missing here. }\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:alphabet}}\\\label{definition:alphabet}An \index{alphabet}\textbf{alphabet} $\Sigma{}$ is a finite \index{set}set of \index{symbol}symbols. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:string}}\\\label{definition:string}A \index{string}\textbf{string} $s$ over an \index{alphabet}alphabet $\Sigma{}$ is a ordered sequence of symbols ${a}_{i}$ in $\Sigma{}$. \[s={a}_{1}\dotsc{}{a}_{n}\]\end{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:empty-string}}\\\label{definition:empty-string}\begin{de}The \index{empty string}\textbf{empty string} $\epsilon{}$ is the \index{string}string of no symbols. \end{de}\begin{nte}$\epsilon{}$ is just the notation for the empty string. It is only used because writing down `nothing', even that word, is impractical. \end{nte}\begin{de}The \index{concatenation}\textbf{concatenation} $xy$ of two strings $x$ and $y$ is the following \index{string}string. \[xy\quad{}\equiv{}\quad{}{x}_{1}{x}_{2}\dotsc{}{x}_{m}{y}_{1}{y}_{2}\dotsc{}{y}_{n}\]\end{de}\begin{thm}The \index{concatenation}concatenation of strings is \index{associative}associative\footnote{See definition \ref{definition:associative} on page \pageref{definition:associative}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:associative}}}. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}The \index{concatenation}concatenation of strings is \emph{not} \index{commutative}commutative. \todo[color=red,inline,size=\small]{There is an counter example missing here.}\end{thm}\begin{de}The \index{set}set of all strings over an \index{alphabet}alphabet $\Sigma{}$ is de:: Noted as ${\Sigma{}}^{*}$. \[{\Sigma{}}^{*}\quad{}\equiv{}\quad{}\left\{{a}_{1}{a}_{2}\dotsc{}{a}_{n}\mid{}{a}_{i}\in{}\Sigma{}, n, i\in{}\mathbb{N}\right\}\]\end{de}\begin{de}The \index{set}set $\Sigma{}\cup{}\left\{\epsilon{}\right\}$ is sometimes written more consisely as ${\Sigma{}}_{\epsilon{}}$. \end{de}\begin{nte}This is not just a set of symbols because $\epsilon{}$ is a string. \end{nte}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:reverse-string}}\\\label{definition:reverse-string}The \index{reverse string}\textbf{reverse string} ${s}^{R}$ of a \index{string}string $s={a}_{1}\dotsc{}{a}_{n}$ is the \index{string}string wherein the symbols of $s$ are ordered in reverse. \[{s}^{R}\quad{}\equiv{}\quad{}{a}_{n}\dotsc{}{a}_{1}\]\end{de}\section{Languages}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:language}}\\\label{definition:language}A \index{language}\textbf{language} over an \index{alphabet}alphabet $\Sigma{}$ is a \index{set}set of finite strings over that \index{alphabet}alphabet. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:concatenation}}\\\label{definition:concatenation}The \index{concatenation}\textbf{concatenation} ${L}_{1}{L}_{2}$ of two languages ${L}_{1}$ and ${L}_{2}$ is the following \index{language}language. \[{L}_{1}{L}_{2}\quad{}\equiv{}\quad{}\left\{{s}_{1}{s}_{2}\mid{}{s}_{1}\in{}{L}_{1}, {s}_{2}\in{}{L}_{2}\right\}\]\end{de}\begin{thm}The \index{concatenation}concatenation of languages is \index{associative}associative\footnote{See definition \ref{definition:associative} on page \pageref{definition:associative}. \colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:associative}}}. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}The \index{concatenation}concatenation of languages is \emph{not} \index{commutative}commutative. \todo[color=red,inline,size=\small]{There is an counter example missing here.}\end{thm}\begin{de}The \index{concatenation}concatenation of a \index{language}language $L$ with itself $n$ times is de:: Noted as ${L}^{n}$. ${L}^{0}$ is defined as $\left\{\epsilon{}\right\}$. \[{L}^{n}\quad{}\equiv{}\quad{}L{L}^{n-1}\]\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:kleene-star}}\\\label{definition:kleene-star}The \index{Kleene star}\textbf{Kleene star} ${L}^{*}$ of a \index{language}language $L$ is the \index{union}union of all the concatenations of $L$ with itself. \[{L}^{*}\quad{}\equiv{}\quad{}{\bigcup_{{n\in{}\mathbb{N}}}}{{L}^{n}}\]\end{de}\begin{de}${L}^{+}$ is defined as $L{L}^{*}$. \end{de}\begin{de}The \index{set}set of all languages over an \index{alphabet}alphabet $\Sigma{}$ is de:: Noted as follows. \[{L}_{\Sigma{}}\quad{}\equiv{}\quad{}\mathcal{P}\kern-2pt\left({\Sigma{}}^{*}\right)\]\end{de}\begin{thm}Infinite languages are countable. \todo[color=red,inline,size=\small]{There is a reference to ``countable'' missing here. }\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}There are uncountably infinitely many languages over a given \index{alphabet}alphabet. \todo[color=red,inline,size=\small]{There is a reference to ``uncountably infinite'' missing here. }\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:reverse-language}}\\\label{definition:reverse-language}The \index{reverse language}\textbf{reverse language} ${L}^{R}$ is the \index{language}language of all reverse strings of the strings in $L$. \[{L}^{R}\quad{}\equiv{}\quad{}\left\{{s}^{R}\mid{}s\in{}L\right\}\]\end{de}\section{Regular Expressions}\begin{de}A \index{regular expression}\textbf{regular expression} (\index{RE}\textbf{RE}) over an \index{alphabet}alphabet $\Sigma{}$ is inductively defined as an expression of the following form. \begin{itemize}\item{}$\epsilon{}$\item{}$\phi{}$\item{}$a\text{ with }a\in{}\Sigma{}$\item{}$\left({E}_{1}{E}_{2}\right)$\item{}$\left({E}_{1}{E}_{2}\right)$\item{}${\left(E\right)}^{*}$\end{itemize}Here, $E, {E}_{1}, {E}_{2}$ must be regular expressions. \end{de}\begin{de}The \index{set}set of \index{regular expression}regular expressions over an \index{alphabet}alphabet $\Sigma{}$ is de:: Noted as ${RegEx}_{\Sigma{}}$. \end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:language-of-a-regular-expression}}\\\label{definition:language-of-a-regular-expression}The \index{language of a regular expression}\textbf{language of a regular expression} ${L}_{E}$ is inductively defined as follows. \begin{figure}[H]\centering{}$\begin{array}[c]{|c|c|c|c|c|c|}\hline E&{L}_{E}\\\hline \hline \epsilon{}&\epsilon{}\\\hline \phi{}&\emptyset{}\\\hline a\text{ with }a\in{}\Sigma{}&\left\{a\right\}\\\hline \left({E}_{1}{E}_{2}\right)&{L}_{{E}_{1}}{L}_{{E}_{2}}\\\hline \left({E}_{1}{E}_{2}\right)&{L}_{{E}_{1}}\cup{}{L}_{{E}_{2}}\\\hline {\left(E\right)}^{*}&{{L}_{E}}^{*}\\\hline \end{array}$\end{figure}\end{de}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:regular}}\\\label{definition:regular}A \index{language}language is called \index{regular}\textbf{regular} if it is the \index{language}language of a \index{regular expression}regular expression. \end{de}\begin{thm}If a \index{regular expression}regular expression does not contain an asterisk, its \index{language}language is finite. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{cex}The inverse of this theorem does not hold. ${L}_{{\left(\phi{}\right)}^{*}}$ is a counter example. \end{cex}\begin{de}The \index{set}set of all \index{regular}regular languages is de:: Noted as $RegLan$. \end{de}\begin{de}$RegLan$ is a subalgebra of ${L}_{\Sigma{}}$. \todo[color=red,inline,size=\small]{There is a reference to ``subalgebra'' missing here. }\todo[color=red,inline,size=\small]{There is a proof missing here.}\end{de}\begin{thm}Every finite \index{language}language is \index{regular}regular. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}Let $L$ be a \index{language}language and $s$ be a \index{string}string over the same \index{alphabet}alphabet $\Sigma{}$. $L\cup{}\left\{s\right\}$ is \index{regular}regular. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}There exist non \index{regular}regular languages. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\begin{thm}For any \index{language}language $L$, ${L}^{R}$ is \index{regular}regular. \todo[color=red,inline,size=\small]{There is a proof missing here.}\end{thm}\section{Finite state automata}\subsection{NFSA}\begin{de}A \index{nondeterministic finite state automaton}\textbf{nondeterministic finite state automaton} is a $5$-tuple $hi$ where the following conents. \begin{enumerate}\item{}$Q$: a finite set of states. \item{}$\Sigma{}$: an alphabet. \item{}$\delta{}\kern-2pt:\, Q\times{}{\Sigma{}}_{\epsilon{}}\rightarrow{}\mathcal{P}\kern-2pt\left(Q\right)$: A transition function. \item{}${q}_{s}$: an initial state. \item{}$F$: a set of accepting states. \end{enumerate}\end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/1ed1c94283a6723a.eps}\caption{A \index{nondeterministic finite state automaton}nondeterministic finite state automaton. }\end{figure}\end{ex}\begin{de}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:accept}}\\\label{definition:accept}\colorbox[rgb]{0.50000,0.50000,0.50000}{\textcolor[rgb]{0.00000,1.00000,0.00000}{definition:reject}}\\\label{definition:reject}A \index{nondeterministic finite state automaton}nondeterministic finite state automaton is said to \index{accept}\textbf{accept} a string $s={s}_{1}{s}_{2}\dotsc{}{s}_{n}$, also called an input word, if there exists a sequence of states ${r}_{1}{r}_{2}\dotsc{}{r}_{n}$ as follows. \begin{itemize}\item{}It starts in the initial state: ${r}_{1}={q}_{s}$. \item{}It ends in an accepting state: ${r}_{n}\in{}F$. \item{}It respects the transition function: \[\forall{}i\in{}\left\{1, \dotsc{}, n\right\}:\ {r}_{i+1}\in{}\delta{}\kern-2pt\left({r}_{i}, {s}_{i}\right)\]Note that this is slightly more simply specified than is actually the case. To make this simplification work, you must assume that between any two symbols in $s$ the empty string $\epsilon{}$ can be inserted if the transition function's symbol is $\epsilon{}$. \end{itemize}A \index{nondeterministic finite state automaton}nondeterministic finite state automaton is said to \index{reject}\textbf{reject} a string $s$ if it does not accept it. \end{de}\begin{ex}\noindent{}\begin{figure}[H]\centering{}\includegraphics[keepaspectratio=true,height=3.00000cm,width=0.5\textwidth{}]{/tmp/8166c19d8fd48cf7.eps}\caption{A \index{nondeterministic finite state automaton}nondeterministic finite state automaton. }\end{figure}This \index{nondeterministic finite state automaton}nondeterministic finite state automaton accepts the strings $p, pq, pqq, pqqq, ...$. \end{ex}\todo[color=red,inline,size=\small]{language of NFSA}\subsection{DFSA}\bibliographystyle{plain}\bibliography{software-verification}\printindex{}\listoftodos{}\end{document}