module Groups.Main where

import           Notes                           hiding (inverse)

import           Functions.Basics.Macro
import           Functions.BinaryOperation.Terms
import           Logic.FirstOrderLogic.Macro
import           Sets.Basics.Terms

import           Groups.Macro
import           Groups.Terms

groups :: Note
groups = chapter "Groups" $ do
    magmaDefinition
    semigroupDefinition
    monoidDefinition
    groupDefinition

    subgroupDefinition
    subgroupSameIdentity
    trivialSubgroupsDT

    generatedSetDefinition
    generatedSetIsGroup

magmaDefinition :: Note
magmaDefinition = de $ do
    lab magmaDefinitionLabel
    s ["A", magma', m mgm_, "is a", set <> ", equipped with a", binaryOperation]
    ma $ fun2 (pars $ "" · "") mgms_ mgms_ mgms_

semigroupDefinition :: Note
semigroupDefinition = de $ do
    lab semigroupDefinitionLabel
    s ["A", magma, m sgrp_, "is called a", semigroup', "if its operation", m $ "" ˙ "", "is", associative_]

monoidDefinition :: Note
monoidDefinition = de $ do
    lab monoidDefinitionLabel
    lab identityDefinitionLabel
    lab neutralElementDefinitionLabel
    s ["A", semigroup, m mnd_, "is called a", monoid', "if it has an", identity', "(or", neutralElement' <> ")", m mid_ <> ":"]
    let a = "a"
    ma $ fa (a ∈ mnds_) $ a ˚ mid_ =: a =: mid_ ˚ a

groupDefinition :: Note
groupDefinition = de $ do
    lab groupDefinitionLabel
    lab inverseDefinitionLabel
    s ["A", monoid, m grp_, "is called a", group', "if every", element, "has an", inverse', "with respect to the", identity, m gid_]
    let a = "a"
        ai = ginv a
    ma $ fa (a ∈ grps_) $ te (ai ∈ grps_) $ a ** ai =: gid_ =: ai ** a

subgroupDefinition :: Note
subgroupDefinition = de $ do
    lab subgroupDefinitionLabel
    let h = "H"
    s ["Let", m grp_, "be a", group, "and let", m h, "be a subset of", m grps_]
    s ["If", m $ grp h grpop_, "is a", group, "in and of itself, it is called a", subgroup', "of", m grp_]

subgroupSameIdentity :: Note
subgroupSameIdentity = thm $ do
    lab subgroupSameIdentityTheoremLabel
    let h = "H"
        sg = grp h grpop_
    s ["Let", m grp_, "be a", group, "and let", m sg, "be a", subgroup, "of", m grp_]
    s [m grp_, and, m sg, "have the same", neutralElement]

    toprove

trivialSubgroupsDT :: Note
trivialSubgroupsDT = thm $ do
    s ["Let", m grp_, "be a", group]
    s [m grp_, and, m $ grp (setof gid_) grpop_, "are subgroups of", m grp_]
    s ["They are called the", trivialSubgroups', "of", m grp_]

    toprove

generatedSetDefinition :: Note
generatedSetDefinition = de $ do
    let x = "x"
    s ["Let", m grp_, "be a", group, "and let", m x, "be an", element, "of", grps_]
    s [the, set, m $ genby x, "generated by", m x, "is defined as follows"]
    let s = "s"
    ma $ genby x === setcmpr (x ^ s) (s ∈ integers)

generatedSetIsGroup :: Note
generatedSetIsGroup = thm $ do
    lab generatedSetIsGroupTheoremLabel
    let x = "x"
    s ["Let", m grp_, "be a", group, "and let", m x, "be an", element, "of", grps_]
    s [m $ grp (genby x) grpop_, "is a", group]
    s ["It is called the", group, "generated by", m x]

    toprove
