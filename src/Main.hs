module Main where

import           System.Exit              (ExitCode (..), die)
import           System.Process           (CreateProcess (..),
                                           readCreateProcessWithExitCode, shell)

import           Notes
import           Utils

import           Text.LaTeX.Base.Warnings

import qualified Data.Text                as T

import           Control.Monad            (when)
import           Data.List                (intercalate, isInfixOf, splitAt)
import           Prelude                  (Bool (..), Int, appendFile, error,
                                           filter, print, putStrLn, return)
import qualified Prelude                  as P

import           Header
import           Packages
import           Parser
import           Titlepage

import           Computability.Main
import           DataMining.Main
import           Fields.Main
import           Functions.Main
import           Groups.Main
import           LinearAlgebra.Main
import           Logic.Main
import           MachineLearning.Main
import           Probability.Main
import           Relations.Main
import           Rings.Main
import           Sets.Main
import           Topology.Main



main :: IO ()
main = do
    mc <- getConfig
    case mc of
      Nothing -> error "Couldn't parse arguments."
      Just cf -> do
        let mainBibFile = conf_bibFileName cf ++ ".bib"
            mainTexFile = conf_texFileName cf ++ ".tex"
            mainPdfFile = conf_pdfFileName cf ++ ".pdf"
        removeIfExists mainBibFile
        (t, endState) <- runNote entireDocument cf startState

        case surpressWarnings (check checkAll t) of
          [] -> do
              renderFile mainTexFile t

              appendFile mainBibFile $ showReferences $ state_refs endState

              (ec, out, err) <- liftIO $ readCreateProcessWithExitCode (latexMkJob cf) ""
              let outputAnyway = do
                    putStrLn out
                    putStrLn err
              case ec of
                ExitFailure _ -> do
                    outputAnyway
                    die "Compilation failed"
                ExitSuccess -> do
                    if containsRefErrors $ out ++ "\n" ++ err
                    then do
                        removeIfExists mainPdfFile
                        outputAnyway
                        die "Undefined references"
                    else when (conf_verbose cf) outputAnyway

              return ()
          ws -> do
              print ws
              die "There were unacceptable warnings."

containsRefErrors :: String -> Bool
containsRefErrors s = P.or $ [t `isInfixOf` l | t <- wrongThings, l <- lines s]
  where
    wrongThings :: [String]
    wrongThings = ["There were undefined references.", "There were multiply-defined labels."]

latexMkJob :: Config -> CreateProcess
latexMkJob cf = shell $ "latexmk " ++ unwords latexMkArgs
  where
    mainTexFile :: FilePath
    mainTexFile = conf_texFileName cf ++ ".tex"

    latexMkArgs :: [String]
    latexMkArgs = ["-pdf", pdfLatexArg, jobNameArg, mainTexFile]

    jobNameArg :: String
    jobNameArg = "-jobname=" ++ conf_pdfFileName cf

    pdfLatexArg :: String
    pdfLatexArg = "-pdflatex='" ++ pdfLatexCmd ++ "'"

    pdfLatexCmd :: String
    pdfLatexCmd = "pdflatex " ++ unwords pdfLatexArgs

    pdfLatexArgs :: [String]
    pdfLatexArgs = ["-shell-escape", "-halt-on-error", "-enable-write18"]

surpressWarnings :: [Warning] -> [Warning]
surpressWarnings = filter leave
  where
    leave :: Warning -> Bool
    leave (UnusedLabel _) = False
    leave _ = True

startState :: State
startState = State {
    state_refs = []
  }

renderConfig :: Note
renderConfig = do
  vspace $ Cm 1
  conf <- ask
  "The code for this pdf was generated by running the `the notes' generator with the following configuration."
  verbatim $ T.pack $ breakUp $ show conf
  raw "\n"
  newpage

breakUp :: String -> String
breakUp = intercalate "\n" . chunk 80

chunk :: Int -> [a] -> [[a]]
chunk _ [] = []
chunk n xs = y1 : chunk n y2
  where (y1, y2) = splitAt n xs


entireDocument :: Note
entireDocument = do
  documentclass [oneside, a4paper] book

  packages
  header

  document $ do
    myTitlePage
    tableofcontents
    renderConfig
    renderNotes allNotes

    comm1 "bibliographystyle" "plain"
    comm1 "bibliography" "main"

    comm0 "printindex"
    comm0 "listoftodos"



allNotes :: Notes
allNotes = notes ""
  [
      logic
    , sets
    , relations
    , functions
    , groups
    , rings
    , fields
    , linearAlgebra
    , topology
    , computability
    , probability
    , machineLearning
    , dataMining
  ]

